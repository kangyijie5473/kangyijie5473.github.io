---
layout: post
title: [LintCode]785.最大权值和路径 (想起了16年小组免试题第五关)
date: 2018-01-31
---

#### 前言


最简单的动归，依稀记得当年小组免试题最后一关就是这样的（恩，是最后一关的前一部分哈），思路和之前的博客一样，做之前又复习了一遍博客，然后就轻松+愉快（哼，才不是呢，一开始没搞懂m，n怎么处理，又不能在类里全局数组&传数组很麻烦，整了半天表。。）


#### 题目


有一个机器人位于一个 m × n 个网格的右上角。机器人每一时刻只能向下或者向左移动一步。机器人试图达到网格的左下角。每个网格上有一个数字权值，机器人希望它走到左下角的路径权值和最大。问这个最大路径权值和是多少？


注意事项


输入一个n x m 的矩阵，保证 n <= 200,m <= 200。（康康提示，nm相等，并且nums数组已经输入好了权值，不用自己手动输入了）题目数据保证 0 <= i <= n-1 , 0 <= j <= m-1, nums[i][j] <= 100000。


样例


给出[[1,2,3,4],[3,5,6,7],[9,10,1,2],[4,4,5,5]]，返回45。


解释：从右上角出发，沿着[4,7,6,5,10,9,4]走到左下角。权值和为45。给出[[1,2,3],[4,5,6],[7,9,8]],返回33。


解释：从右上角出发，沿着[3,6,8,9,7]走到左下角，权值和为33。


#### 直接上题解


```
class Solution {
public:
    /**
     * @param nums: the n x m grid
     * @return: the maximum weighted sum
     */
     int m;
     int n;
    int maxWeight(vector<vector<int>> &nums) {
        m = n = nums.size();
        vector<vector<int>> table;

        for(int i = 0; i < m; i++){
            vector<int> temp;
            table.push_back(temp);
            for(int j = 0; j < n;j++){
                table[i].push_back(0) ;
            }
        }

        return result(0, n-1, nums, table);
    }
    int result(int i, int j, vector<vector<int>> &nums,  vector<vector<int>> &table){
        if(table[i][j] != 0)
            return table[i][j];
        if(i == m - 1 && j == 0)
            return table[i][j] = nums[i][j];
        if(i == m -1)
            return table[i][j] = nums[i][j] + result(i, j-1, nums,table);
        if(j == 0)
            return table[i][j] = nums[i][j] + result(i+1, j, nums,table);
        return table[i][j] = nums[i][j] + max(result(i, j-1, nums,table), result(i+1, j, nums,table));
    }
};
```
