---
layout: post
title: "【网络编程】处理定时事件（三）---看看Libco的时间轮"
date: 2017-11-09
---

#### 前言


你以为我鸽了其实我没有鸽，这也算是一种鸽。继续来填坑啦。


在上两篇中，我们都是使用的链表进行保存定时事件，当我们需要增加一个或者删除一个事件时都需要O(n)的时间复杂度，本篇我们通过时间轮（time wheel）这种数据结构来对其进行优化，而libco也是通过时间轮来进行处理的，所以就拿着它的代码来讲啦。


### 正文


Libco的作为一个协程库，相当于在用户态完成了逻辑流的切换，这里的调度便是一旦遇到阻塞的系统调用（如read）时，将其注册到epoll_wait中并切换逻辑流，等待其I/O事件的到达，一旦到达则进行处理，将同步阻塞I/O换成了I/O多路复用。


而这里便是将I/O事件当作定时事件来处理，将I/O事件设置超时事件，如果超时则直接处理，避免一直等待的情况。


libco管理定时事件便是使用时间轮这种数据结构，通过一种hash的思想使得添加定时事件的时间复杂度降到O(1)，大大提高了效率。我们先来看看时间轮是怎样的东西。


#### 时间轮是个啥


在之前我们通过链表，按照超时时间进行升序或者降序的排列，这样添加事件就需要O(N)的时间复杂度。而时间轮则将多条链表组合起来，每条链表上的事件都是同样的超时时间，而两条链表超时时间的差值t就是处理超时事件的时间间隔。时间轮内部有一个指针指向当前的链表，t时间过去，t指向下一个链表，判断是否超时。而当我们想要添加一个定时事件，只需要知道它的超时时间，再除以t，就是它应该插入的位置。


如图，当前指向1号链表，t为50ms，当需要添加一个定时为100ms的定时事件时，直接添加到3号链表即可（O(1)）。（图转自https://www.ibm.com/developerworks/cn/linux/l-cn-timers/index.html）
![pic](/images/eac60c76-676e-4e6d-bfe1-52155e05fbc0.png)


#### libco的主循环分析


让我们看看这里的主循环，为了思路清晰，删除部分无关代码


```
void co_eventloop( stCoEpoll_t *ctx,pfn_co_eventloop_t pfn,void *arg )
{

    co_epoll_res *result = ctx->result;


    for(;;)
    {
    /*在之前的博客中，为了达到定时查看的效果，我们使用epoll_wait的超时参数或者定时信号，而这里则是让epoll_wait以一个非常短的间隙（1ms）返回*/
        int ret = co_epoll_wait( ctx->iEpollFd,result,stCoEpoll_t::_EPOLL_SIZE, 1 );

        stTimeoutItemLink_t *active = (ctx->pstAct
```
