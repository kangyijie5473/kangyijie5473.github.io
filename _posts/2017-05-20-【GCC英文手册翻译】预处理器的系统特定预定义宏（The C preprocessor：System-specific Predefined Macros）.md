---
layout: post
title: "【GCC英文手册翻译】预处理器的系统特定预定义宏（The C preprocessor：System-specific Predefined Macros）"
date: 2017-05-20
---

翻译自GCC英文手册–预处理器篇The C Preprocessor：System-specific Predefined Macros


3.7.3 系统特定的预定义宏


正常情况下，C预处理器会预定义几个宏来说明正在使用的系统类型和机器类型。 很明显，在每个GCC支持的目标(机器/系统)上，他们都是不同的。 这份手册是对于所有的系统和机器的，所以不能告诉你这些宏具体的名字是什么，但你可以使用cpp -dM来查看它们。 所有的系统特定预处理宏都被展开为一个常量，所以你可以用#ifdef或者#if来测试它们。


标准C需要所有的系统特定宏成为保留命名空间的一部分。 用两个下划线开头，或者一个下划线加一个大写字母开头的所有名字，都是为编译器和库保留的，为了能按照他们希望的那样使用。


然而，由于历史原因，系统特定宏有一些名字并没有特殊前缀。例如，在Unix系统上，一般都能找到unix这个宏。 对于所有这样的无特殊前缀系统特定宏，GCC提供了一种并行宏(a parallel macro)，它们的特点是名字开头和结尾添加两个下划线。 还是用上面的例子，如果unix宏被定义了，那么__unix__宏也将被定义。 但是开头和结尾绝对不可能多于两个下划线，像_mips的并行宏就是__mips__。


当有-ansi或者任何-std这类的要求严格一致性 的参数被传给编译器时，所有在保留命名空间之外的系统特定宏都被禁止，而在保留命名空间里面的并行宏仍然被定义。


我们会慢慢淘汰在保留命名空间外的系统特定宏。你绝不应该在新程序里面再使用它们了。并且我们也鼓励你，修正老程序里面的系统特定宏。我们也不推荐你使用在保留命名空间里面的系统特定宏。如果你想对你需要的特定功能检查，最好长期用autocof这样的工具。


### 译者总结


系统特定宏是为了程序跨平台的使用，一次编写，到处编译，但是这些系统特定宏的命名十分混乱，为了保证这些随意命名的宏依然能使用，GCC采取了并行宏的做法，但是GCC依然不推荐通过这些宏来达到这种跨平台编译的目的，而是通过autocof这样的工具，在源码编译时对系统进行检测然后对编译过程进行控制，而不是用宏。
