---
layout: post
title: "如何查看进程运行在哪个CPU上"
date: 2019-01-25
---

#### 前言


最近大家都在积极的写博客呀，咸鱼也不能落下。


### 正文


需要注意的是， 下面的两种方法，我们获得的都是逻辑core的编号。比如我的CPU是四核八线程，通过/proc/cpuinfo，就能看到8个core，编号0-7.而我们查看的话，也就是看位于core的编号是啥。。。


#### 外部方法


主要通过ps命令来进行观察，


```
$ ps -o psr -p <pid>
```


#### 程序中查看


在程序中通过sched_getcpu()可以查看当前进程当前所运行在哪个cpu，如果想要查看别的进程可以通过/proc/<pid>/stat查看查看的方式就有点粗暴了。


下面引用自stackoverflow


```
struct pstat
{
  int  pid;       //process id
  char tcomm[256];//filename of the executable
  char state[2];  //state (R is running, S is sleeping, D is sleeping in an
                  //uninterruptible wait, Z is zombie, T is traced or stopped)
  int ppid;//          process id of the parent process
  int pgrp;//          pgrp of the process
  int sid;//           session id
  int tty_nr;//        tty the process uses
  int tty_pgrp;//      pgrp of the tty
  int flags;//         task flags
  int min_flt;//       number of minor faults
  int cmin_flt;//      number of minor faults with child's
  int maj_flt;//       number of major faults
  int cmaj_flt;//      number of major faults with child's
  int utime;//         user mode jiffies
  int stime;//         kernel mode jiffies
  int cutime;//        user mode jiffies with child's
  int cstime;//        kernel mode jiffies with child's
  int priority;//      priority level
  int nice;//          nice level
  int num_threads;//   number of threads
  int it_real_value;//  (obsolete, always 0)
  int start_time;//    time the process started after system boot
  int vsize;//         virtual memory size
  int rss;//           resident set memory size
  int rsslim;//        current limit in bytes on the rss
  int start_code;//    address above which program text can run
  int end_code;//      address below which program text can run
  int start_stack;//   address of the start of the stack
  int esp;//           current value of ESP
  int eip;//           current value of EIP
  int pending;//       bitmap of pending signals
  int blocked;//       bitmap of blocked signals
  int sigign;//        bitmap of ignored signals
  int sigcatch;//      bitmap of catched signals
  int wchan;//         address where process went to sleep
  int i0;//             (place holder)
  int i1;//             (place holder)
  int exit_signal;//   signal to send to parent thread on exit
  int task_cpu;//      which CPU the task is scheduled on
  int rt_priority;//   realtime priority
  int policy;//        scheduling policy (man sched_setscheduler)
  int blkio_ticks;//   time spent waiting for block IO
  int gtime;//         guest time of the task in jiffies
  int cgtime;//        guest time of the task children in jiffies
} p ;

int main()
{
    char name[256];
    char state[8];
    FILE* f = fopen("/proc/pid/stat", "r"); //这里pid换成你想要查看的进程号

    fscanf(f,  "%d%s%s%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d",
           &p.pid, &p.tcomm, &p.state, &p.ppid, &p.pgrp, &p.sid, &p.tty_nr, &p.tty_pgrp, &p.flags,
           &p.min_flt, &p.cmin_flt, &p.maj_flt, &p.cmaj_flt, &p.utime, &p.stime,  &p.cutime, &p.cstime,
           &p.priority, &p.nice, &p.num_threads, &p.it_real_value, &p.start_time,  &p.vsize, &p.rss,
           &p.rsslim, &p.start_code, &p.end_code, &p.start_stack, &p.esp, &p.eip,  &p.pending, &p.blocked,
           &p.sigign, &p.sigcatch, &p.wchan, &p.i0, &p.i1, &p.exit_signal,  &p.task_cpu, &p.rt_priority, &p.policy,
           &p.blkio_ticks, &p.gtime, &p.cgtime);

     printf("CPU %d\n", p.task_cpu);
 	return 0;  
 }
```


#### CPU指令


如果当前CPU支持的话（判断方法$ cat /proc/cpuinfo | grep cpuid），直接调用指令CPUID。能获取CPU信息，不过这个方法好像和我们最初的需求–在哪个core上关系不大，只是拓展了解。
