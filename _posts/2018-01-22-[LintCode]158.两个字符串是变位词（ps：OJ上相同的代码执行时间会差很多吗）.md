---
layout: post
title: "[LintCode]158.两个字符串是变位词（ps：OJ上相同的代码执行时间会差很多吗）"
date: 2018-01-22
---

#### 前言


简单的题，一次就AC的感觉真爽。


### 正文


#### 题目


判断两个字符串是否可以通过改变字母的顺序变成一样的字符串。样例给出 s = “abcd”，t=”dcab”，返回 true.给出 s = “ab”, t = “ab”, 返回 true.给出 s = “ab”, t = “ac”, 返回 false.


我的想法就是把两个字符串原地排序，排序之后就可以比较了。直接就是简单粗暴的std::sort….


```
sort(s.begin(),s.end(),[](const char a,const char b){return a > b;});
    sort(t.begin(),t.end(),[](const char a,const char b){return a > b;});
    if(s == t)
         return true;
    else 
         return false;
```


692ms，好像有点慢。。。


看了一眼别人的题解。。enmmmm其实上来应该先判断长度。。毕竟长度不同肯定不同。。。


```
if(s.length() != t.length())
            return false;
```


恩，快一点了。622ms


发现没有一个人像我这样直接排序，都是开了额外的空间？哦，原来这个题的挑战是 时间O(n)，空间O(1)。


恩，那就用桶排序的思路，统计一下每个字符的个数，如果不相同那么直接false


```
bool anagram(string s, string t) {
        if(s.length() != t.length())
            return false;

        int a[128] = {0}, b[128] = {0};
        int length = s.length();
        for(int i = 0; i < length; i++){
            a[s[i]]++,b[t[i]]++;
        }
        for(int i = 0; i < 128; i++){
            if(a[i] != b[i])
                return false;
        }
        return true;
    }
```


700ms左右enmmmm，还可以吧。


#### 额外的想法


LintCode上每次提交都可以看到程序用的时间，那么同一份代码会不会第一次执行时和第二次执行时差很多呢？比如执行一次后有缓存，啥的之类的，抱着这个想法我又试了试我的stl排序解法，发现可以在500ms左右，桶排序在700ms左右。。。求解~
