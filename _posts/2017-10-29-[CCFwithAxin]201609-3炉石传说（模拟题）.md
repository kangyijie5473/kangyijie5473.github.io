---
layout: post
title: [CCFwithAxin]201609-3炉石传说（模拟题）
date: 2017-10-29
---

前言
一道由小树林引出的题，模拟题很适合练习Ｃ++。但是不知道为什么只有90分。。。
问题描述
　　《炉石传说：魔兽英雄传》（Hearthstone: Heroes of Warcraft，简称炉石传说）是暴雪娱乐开发的一款集换式卡牌游戏（如下图所示）。游戏在一个战斗棋盘上进行，由两名玩家轮流进行操作，本题所使用的炉石传说游戏的简化规则如下：
　　* 玩家会控制一些角色，每个角色有自己的生命值和攻击力。当生命值小于等于 0 时，该角色死亡。角色分为英雄和随从。  　　* 玩家各控制一个英雄，游戏开始时，英雄的生命值为 30，攻击力为 0。当英雄死亡时，游戏结束，英雄未死亡的一方获胜。  　　* 玩家可在游戏过程中召唤随从。棋盘上每方都有 7 个可用于放置随从的空位，从左到右一字排开，被称为战场。当随从死亡时，它将被从战场上移除。  　　* 游戏开始后，两位玩家轮流进行操作，每个玩家的连续一组操作称为一个回合。  　　* 每个回合中，当前玩家可进行零个或者多个以下操作：  　　1) 召唤随从：玩家召唤一个随从进入战场，随从具有指定的生命值和攻击力。  　　2) 随从攻击：玩家控制自己的某个随从攻击对手的英雄或者某个随从。  　　3) 结束回合：玩家声明自己的当前回合结束，游戏将进入对手的回合。该操作一定是一个回合的最后一个操作。  　　* 当随从攻击时，攻击方和被攻击方会同时对彼此造成等同于自己攻击力的伤害。受到伤害的角色的生命值将会减少，数值等同于受到的伤害。例如，随从 X 的生命值为 HX、攻击力为 AX，随从 Y 的生命值为 HY、攻击力为 AY，如果随从 X 攻击随从 Y，则攻击发生后随从 X 的生命值变为 HX - AY，随从 Y 的生命值变为 HY - AX。攻击发生后，角色的生命值可以为负数。  　　本题将给出一个游戏的过程，要求编写程序模拟该游戏过程并输出最后的局面。
输入格式
　　输入第一行是一个整数 n，表示操作的个数。接下来 n 行，每行描述一个操作，格式如下：  　　action arg1 arg2 …  　　其中action表示操作类型，是一个字符串，共有 3 种：summon表示召唤随从，attack表示随从攻击，end表示结束回合。这 3 种操作的具体格式如下：  　　* summon position attack health：当前玩家在位置position召唤一个生命值为health、攻击力为attack的随从。其中position是一个 1 到 7 的整数，表示召唤的随从出现在战场上的位置，原来该位置及右边的随从都将顺次向右移动一位。  　　* attack attacker defender：当前玩家的角色attacker攻击对方的角色 defender。attacker是 1 到 7 的整数，表示发起攻击的本方随从编号，defender是 0 到 7 的整数，表示被攻击的对方角色，0 表示攻击对方英雄，1 到 7 表示攻击对方随从的编号。  　　* end：当前玩家结束本回合。  　　注意：随从的编号会随着游戏的进程发生变化，当召唤一个随从时，玩家指定召唤该随从放入战场的位置，此时，原来该位置及右边的所有随从编号都会增加 1。而当一个随从死亡时，它右边的所有随从编号都会减少 1。任意时刻，战场上的随从总是从1开始连续编号。
输出格式
　　输出共 5 行。  　　第 1 行包含一个整数，表示这 n 次操作后（以下称为 T 时刻）游戏的胜负结果，1 表示先手玩家获胜，-1 表示后手玩家获胜，0 表示游戏尚未结束，还没有人获胜。  　　第 2 行包含一个整数，表示 T 时刻先手玩家的英雄的生命值。  　　第 3 行包含若干个整数，第一个整数 p 表示 T 时刻先手玩家在战场上存活的随从个数，之后 p 个整数，分别表示这些随从在 T 时刻的生命值（按照从左往右的顺序）。  　　第 4 行和第 5 行与第 2 行和第 3 行类似，只是将玩家从先手玩家换为后手玩家。
样例输入
8  summon 1 3 6  summon 2 4 2  end  summon 1 4 5  summon 1 2 1  attack 1 2  end  attack 1 1
样例输出
0  30  1 2  30  1 2
样例说明
　　按照样例输入从第 2 行开始逐行的解释如下：  　　1. 先手玩家在位置 1 召唤一个生命值为 6、攻击力为 3 的随从 A，是本方战场上唯一的随从。  　　2. 先手玩家在位置 2 召唤一个生命值为 2、攻击力为 4 的随从 B，出现在随从 A 的右边。  　　3. 先手玩家回合结束。  　　4. 后手玩家在位置 1 召唤一个生命值为 5、攻击力为 4 的随从 C，是本方战场上唯一的随从。  　　5. 后手玩家在位置 1 召唤一个生命值为 1、攻击力为 2 的随从 D，出现在随从 C 的左边。  　　6. 随从 D 攻击随从 B，双方均死亡。  　　7. 后手玩家回合结束。  　　8. 随从 A 攻击随从 C，双方的生命值都降低至 2。  评测用例规模与约定  　　* 操作的个数0 ≤ n ≤ 1000。  　　* 随从的初始生命值为 1 到 100 的整数，攻击力为 0 到 100 的整数。  　　* 保证所有操作均合法，包括但不限于：  　　1) 召唤随从的位置一定是合法的，即如果当前本方战场上有 m 个随从，则召唤随从的位置一定在 1 到 m + 1 之间，其中 1 表示战场最左边的位置，m + 1 表示战场最右边的位置。  　　2) 当本方战场有 7 个随从时，不会再召唤新的随从。  　　3) 发起攻击和被攻击的角色一定存在，发起攻击的角色攻击力大于 0。  　　4) 一方英雄如果死亡，就不再会有后续操作。  　　* 数据约定：  　　前 20% 的评测用例召唤随从的位置都是战场的最右边。  　　前 40% 的评测用例没有 attack 操作。  　　前 60% 的评测用例不会出现随从死亡的情况。
题解
网上其他的代码挺清晰的，就是模拟，但是我们这里主要练习一下C++的使用，就多多使用STL和面向对象的思想。
C++98版  C++11完整版本
C++11版

```
#include <vector>
#include <iostream>
using namespace std;
class Minion;
class Hero{
public:
    Hero():hp(30){};
    Hero(const Hero&) = delete;
    Hero &operator=(Hero &) = delete;
    ~Hero() = default;
    int hp;
    int attack(Hero &enemy, int minionNum, int enemyNum);
    int underAttack(int minionNum, int attackNum);
    void summon(int postion, int attackNum, int hp);
    void printMinion();
private:
    void judgeMinion(int minionNum);
    vector<Minion> minionList;
    Minion &getMinion(int minionNum);
};
class Minion{
public:

    Minion(int Id, int AttackNum, int Hp): id(Id), attackNum(AttackNum),hp(Hp){}
    void attack(Hero & enemy, int id);
    int id;
    int hp;
    int attackNum;

};
void judgeHero(Hero &first, Hero &second){
    if(first.hp > 0 && second.hp > 0){
        cout << 0 << endl;
        return ;
    }
    if(first.hp){
        cout << 1 << endl;
        return;
    }else{
        cout << -1 << endl;
        return;
    }

}
int main(void)
{
    Hero player_first;
    Hero player_second;
    int n,postion, attackNum, hp, attacker, defender;
    cin >> n;
    string cmd;
    while(n){
        while(n){//先手玩家回合
            cin >> cmd;
            if(cmd == "end"){
                n--;
                break;
            }
            if(cmd == "summon"){
                cin >> postion >> attackNum >> hp;
                player_first.summon(postion, attackNum, hp);
                n--;
                continue;
            }
            if(cmd == "attack"){
                cin >> attacker >> defender;
                player_first.attack(player_second, attacker, defender);
                n--;
                continue;
            }
        }
        while(n){//后手玩家回合
            cin >> cmd;
            if(cmd == "end"){
                n--;
                break;
            }
            if(cmd == "summon"){
                cin >> postion >> attackNum >> hp;
                player_second.summon(postion, attackNum, hp);
                n--;
                continue;
            }
            if(cmd == "attack"){
                cin >> attacker >> defender;
                player_second.attack(player_first, attacker, defender);
                n--;
                continue;
            }
        }
    }
    judgeHero(player_first, player_second);//判断谁赢
    cout << player_first.hp << endl;
    player_first.printMinion();//打印随从状态
    cout << player_second.hp << endl;
    player_second.printMinion();
}
int Hero::underAttack(int minionNum, int attackNum)
{
    getMinion(minionNum).hp -= attackNum;//被攻击
    int couterAttackNum = getMinion(minionNum).attackNum;//取得被攻击随从的攻击力
    judgeMinion(minionNum);//判断被攻击之后的随从状态
    return couterAttackNum;
}
void Hero::judgeMinion(int minionNum)
{
    bool flag = false;
    for(auto i = minionList.begin(); i != minionList.end(); ){
        if(i->hp <= 0){
            i = minionList.erase(i);
            flag = true;
            continue;
        }
        i++;
    }
    if(flag){
        for(auto i = minionList.begin(); i != minionList.end(); i++)
            if(i->id > minionNum)
                i->id--;
    }
}

void Hero::summon(int postion, int attackNum, int hp)//召唤随从
{
    for(auto i = minionList.begin(); i != minionList.end(); i++){
        if(i->id >= postion)//右移（id+1）
            i->id++;
    }
    minionList.push_back(Minion(postion, attackNum, hp));
}
Minion &Hero::getMinion(int minionNum)
{
    for(auto minion = minionList.begin();
        minion != minionList.end();
        minion++)
        if(minion->id == minionNum)
            return *minion;
}
void Hero::printMinion()
{
    cout << minionList.size() << " ";
    for(int i = 1; i <= minionList.size(); i++){
        cout << getMinion(i).hp << " ";
    }
    cout << endl;
}
int Hero::attack(Hero &enemy, int minionNum, int enemyNum)
{
    getMinion(minionNum).attack(enemy, enemyNum);//让指定随从攻击
    judgeMinion(minionNum);//攻击之后判断攻击的随从状态（是否死亡）
    return 0;
}
void Minion::attack(Hero &enemy, int id)
{
    if(!id){
        enemy.hp -= this->attackNum;//攻击英雄
        return;
    }
    int attack;//取得被攻击随从的攻击力
    attack = enemy.underAttack(id, this->attackNum);
    this->hp -= attack;//受到反击
}
```

