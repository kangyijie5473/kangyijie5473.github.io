---
layout: post
title: 【网络编程】半同步--半异步线程池源码分析之任务队列（基于C++11）
date: 2017-07-27
---

前言
对于C++的学习，感觉如果只看书，学习效率很低。很多新知识新概念理解起来都很困难，而C++11更是引入了更多新的概念和知识。而在学习服务端这部分，什么“同步–异步”也把人搞得很晕 
如果看不懂书，看不懂概念，不如就找个例子分析一下，起码能让你快速上手。 
想起了老陈给我们上《操作系统》时讲的要把理论和实例化的东西相结合，对于我这种笨笨的娃尤其适宜，只有理论实在看不懂ToT。
本文主要通过一个实例（半同步–半异步线程池）的源码分析，体会服务端中的并发模式，同时，由于代码几乎完全使用C++11开发，也会针对C++11的新概念进行讲解。  所以本文适合于希望学习C++11/服务端开发的小伙伴。  这个例子出自《深入应用C++11—代码优化与工程级应用》的第9章。源代码已经开源在作者的github上。 原代码地址

正文
同步队列模板类SyncQueue
让我们先看一下私有成员变量：

```
private:
    std::list<T> m_queue;               //使用std::list来保存任务
    std::mutex   m_mutex;               //C++11的互斥锁 用于线程同步
    std::condition_variable m_notEmpty; //C++11的条件变量,用于保证线程执行的次序 
    std::condition_variable m_notFull;  //同上
    int m_maxsize;                      //队列中允许保存的最大任务数
    bool m_needStop;                    //用于终止队列的标志，默认为false
};
```

构造函数
    
```
//构造函数：这里实现的较为简单，主要是记录了队列允许的最大任务数，同时将终止队列的标志m_needStop设置为false
    SyncQueue(int maxsize) : m_maxsize(maxsize), m_needStop(false) {}
```

让我们先来看最简单的3个public方法，主要使用互斥量std::mutex 来保证对队列访问的互斥
    
```
//这三个public方法涉及到队列的计数（size方法），因此在调用时要加锁
    //这里使用std::lock_gu
```

