---
layout: post
title: "浅谈库，进程，线程---C语言学习（5）"
date: 2016-07-30
---

##### 前述


最近要总结的东西好多，因为讲座讲了很多，但是感觉虽然面很广，但是理解的并不深入，本篇只是记录一下现在的理解，以后深入研究后再回来纠正吧。


#### 正文


主要说说静态库和动态库，然后进程和线程只是说一些特殊的需要注意的地方吧。


1.静态库制作方法是将写好的函数先编译，然后用ar命令制作库。


```
gcc -c fun.c -o libfun.o //编译生成目标文件
ar rcvs libfun.a libfun.o //将目标文件制作为一个静态库
gcc main.c -static -L. -lfun // -L指明静态库所在位置 -l加库名
```


要注意的是ar生成的文件必须名字为lib*.a 这样链接器才能正确找到


静态库的好处 库函数在程序编译时就载入可执行程序中，因此程序运行时不再需要库了。缺点，所有的库函数都在程序中，所以使得程序体积很大，也许库里边有10个函数，但我只需要一个，但我依然要将剩余的9个也链接到程序中，造成空间的浪费。其次，对库函数的改动后就必须再次编译，链接。


2.动态库动态库的优势便是弥补了静态库的不足，动态库在编译时不载入程序，在运行时需要调用库函数才会去载入，使得程序体积“瘦身”，同时，对库函数的更新（不改变函数类型），不需要再次链接，只需要更新库函数。


```
gcc -fPIC -shared fun.c -o libfun.so
gcc main.c -L. -lfun
```


我对动态库的理解便是将库函数编译链接后，程序知道去哪里找到需要调用函数的入口，所以当需要更新库函数时，只需要再次编译，可执行文件就完成了更新。（此处理解不是很透彻，只是说了目前的理解，肯定不准确，以后再深入）


动态库的不足便是需要保证运行时的环境，确保能够成功地找到需要的函数。


3.进程线程首先说一个很重要的概念，线程的创建pthread_create()封装了clone（）函数，所以线程也可以看成是一个轻量级的进程。


frok创建子进程，父子进程共享.text段，子进程获得父进程数据段、堆和栈的副本，由于在fork之后经常跟随者exec，所以很多实现并不执行父进程数据段、堆和栈的完全复制，而是使用写时复制（Copy-On-Write,COW）技术。这些区域由父子进程共享，并被内核设为只读，如果父子进程试图修改这些区域，则内核只为修改区域的那块内存制作一个副本。所以当我们写下这样一个程序时


```
int main(void)
{
    printf("xiyou linux group");
    fork();
}
```


结果会打印两次xiyou linux group第一次父进程将打印的字符放在stdout中，操作系统仅仅是把该内容放到了stdout的缓冲队列里了,并没有实际的写到屏幕上，但是,只要看到有 \n 则会立即刷新stdout,因此就马上能够打印了，否则当进程结束时才会打印。子进程stdout缓冲里面也有字符串，所以两个进程结束时都会打印一次。
